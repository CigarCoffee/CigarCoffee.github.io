{"meta":{"title":"Cigar&Coffee","subtitle":"--'s Blog","description":null,"author":"Coffee","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"19.4.21","slug":"19-4-21","date":"2019-04-21T14:11:46.000Z","updated":"2019-04-21T14:18:01.164Z","comments":true,"path":"2019/04/21/19-4-21/","link":"","permalink":"http://yoursite.com/2019/04/21/19-4-21/","excerpt":"","text":"这周主要学习多线程及一部分有关JVM的东西。安装了ubuntu，试了试linux下的eclipse 。总结一下学习JAVA多线程编程遇到的问题及注意事项：安卓中HTTP等网络请求不能在主线程执行，否则会报错：android.os.NetworkOnMainThreadException创建多线程任务的三种方法：继承Thread复写run、实现Runnable接口、通过Threadpool使用isInterrupted（）控制多线程中的循环时不能中断一些处于阻塞状态的I/O操作。比如写文件，或者socket传输等。这种情况，需要同时调用正在阻塞操作的close方法，才能够正常退出。使用volatile修饰的变量控制循环时同理。java中实现同步的方式大体分为以下几种： synchronized关键字 wait、notify等 Concurrent包中的ReentrantLock volatile关键字 ThreadLocal局部变量volatile的目标是基本类型和它锁的基本对象。假如是它修饰的是集合类，比如Map，那么它保证的读可见是map的引用，而不是map对象。ThreadLocal每次使用完都调用expungeStaleEntry来清除数据。","categories":[],"tags":[]},{"title":"关于github里的另一个项目","slug":"关于github里的另一个项目","date":"2019-03-30T11:37:34.000Z","updated":"2019-03-30T11:40:56.353Z","comments":true,"path":"2019/03/30/关于github里的另一个项目/","link":"","permalink":"http://yoursite.com/2019/03/30/关于github里的另一个项目/","excerpt":"","text":"那个其实是高中时的作品，用AIDE做的扫雷小游戏，大概用的都是一些安卓原生的绘图接口还有大量的第三方库hh。有兴趣可以试试。经过几个版本的更迭，目前兼容性和运行速度还是可以的。至于会不会对手机造成什么不良影响emm…哈哈。至少我没发现我和同学的手机有什么异常 XD","categories":[],"tags":[]},{"title":"There's Coffee","slug":"Coffee","date":"2019-03-30T04:29:12.000Z","updated":"2019-03-30T11:24:27.421Z","comments":true,"path":"2019/03/30/Coffee/","link":"","permalink":"http://yoursite.com/2019/03/30/Coffee/","excerpt":"","text":"My Github12Welcome to my blog. There's my github:https://github.com/CigarCoffee/","categories":[],"tags":[]}]}